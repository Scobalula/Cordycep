#include "pch.h"
#if _WIN64
#include "Parasyte.h"
#include "CoDIWHandler.h"
#include "lz4.h"
#include "LZ4DecompressorV2.h"

// Internal
namespace ps::CoDIWInternal
{
	// The fast file decompressor.
	std::unique_ptr<Decompressor> FFDecompressor;
	// The patch file decompressor.
	std::unique_ptr<Decompressor> FPDecompressor;

	// The xasset buffer sizes definition.
	struct BufferSizes
	{
		uint64_t     Unk[3];
		uint64_t     DataSizes[18];
	};
	// The asset file reference definition.
	struct AssetFileRef
	{
		uint64_t StartOffset;
		uint64_t EndOffset;
		uint16_t PackageIndex;
	};
	// Sound Files
	std::array<HANDLE, 512> AssetPacks;

	// Blank Graphics Dvar Buffer
	char GraphicsDvarBuffer[512]{};
	// Graphics Related Dvar
	char** GraphicsDvar = nullptr;
	// Current Images Index.
	size_t ImageIndex = 0;
	// Current Images Count.
	size_t ImageCount = 0;
	// Current Images Buffer.
	AssetFileRef* ImageBuffer = nullptr;

	// A list of pointers for each buffer.
	uint8_t** AssetAlignmentPointers = nullptr;
	// A list of offsets for each buffer.
	uint8_t* AssetAlignmentBuffer = nullptr;
	// The current xasset header being read.
	void** VarXAssetHeader = nullptr;
	// The current zone loader mode.
	uint8_t* ZoneLoader_Mode = nullptr;


	// The function to handle parsing the fast file within the game's exe.
	void* (__cdecl* ParseFastFile)(const void* unk1, const char* AssetList, const char* name, bool unk);
	// The function to handle assigning the memory pointers
	void(__cdecl* AssignMemoryPointers)(void* blocks);
	// The function to handle initializing asset alignment.
	void(__cdecl* AssetAlignmentInit)();
	// The function to handle on asset link.
	void(__cdecl* AssetAlignmentOnAssetLink)();
	// The function to handle getting the asset name.
	const char* (__fastcall* GetXAssetName)(uint32_t assetType, void* xassetHeader);
	// The function to handle setting the asset name.
	const char* (__fastcall* SetXAssetName)(uint32_t assetType, void* xassetHeader, const char* name);
	// The function to handle getting the asset size.
	const size_t(__fastcall* GetXAssetPoolSize)(uint32_t xassetType);

	// The function to handle reading a single xasset header and its data.
	void* (__fastcall* AllocXAssetHeader)();
	// The function to handle reading a single xasset header and its data.
	void* (__fastcall* LoadXAssetHeader)(uint32_t atStreamStart);
	// The function to handle reseting the db pointers.
	void(__fastcall* PushZoneBlock)(uint32_t index);
	// The function to handle reseting the db pointers.
	void(__fastcall* PopZoneBlock)();

	// Requests a handle to an asset file for use with shared data loading.
	HANDLE AssetFile_RequestFile(uint16_t index)
	{
		ps::log::Log(ps::LogType::Verbose, "Requesting asset file index: %i", index);

		HANDLE handle = AssetPacks[index];

		if (handle == NULL)
		{
			auto soundFilePath = ps::Parasyte::GetCurrentHandler()->GameDirectory + "\\" + "assetfile" + std::to_string(index) + ".pak";

			ps::log::Log(ps::LogType::Verbose, "Asset file not open. Attempting to open asset file: %s", soundFilePath.c_str());

			AssetPacks[index] = CreateFileA(
				soundFilePath.c_str(),
				FILE_READ_DATA | FILE_READ_ATTRIBUTES,
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL,
				OPEN_EXISTING,
				0,
				NULL);

			handle = AssetPacks[index];
		}

		return handle;
	}

	// Reads compressed data from the file.
	void ReadXFile(void* ptr, size_t size)
	{
		FFDecompressor->Read(ptr, size, 0);
	}

	// Allocates a string entry within our handler.
	__int64 AllocateString(const char* str, unsigned int user)
	{
		auto strLen = strlen(str) + 1;
		auto id = XXHash64::hash(str, strLen, 0);
		auto potentialEntry = ps::Parasyte::GetCurrentHandler()->StringLookupTable->find(id);

		if (potentialEntry != ps::Parasyte::GetCurrentHandler()->StringLookupTable->end())
		{
			return (int)potentialEntry->second;
		}

		auto offset = ps::Parasyte::GetCurrentHandler()->StringPoolSize;
		std::memcpy(&ps::Parasyte::GetCurrentHandler()->Strings[offset], str, strLen);
		ps::Parasyte::GetCurrentHandler()->StringPoolSize += strLen;
		ps::Parasyte::GetCurrentHandler()->StringLookupTable->operator[](id) = offset;

		return offset;
	}

	// Gets the size of the xasset header for the given type.
	size_t GetXAssetTypeSize(const size_t type)
	{
		// Autogenerated! DO NOT EDIT!
		switch (type)
		{
		case 0: return 24;
		case 1: return 32;
		case 2: return 32;
		case 3: return 80;
		case 4: return 32;
		case 5: return 24;
		case 6: return 136;
		case 7: return 56;
		case 8: return 736;
		case 9: return 80;
		case 10: return 280;
		case 11: return 40;
		case 12: return 40;
		case 13: return 40;
		case 14: return 40;
		case 15: return 40;
		case 16: return 2280;
		case 17: return 56;
		case 18: return 112;
		case 19: return 208;
		case 20: return 352;
		case 21: return 24;
		case 22: return 384;
		case 23: return 104;
		case 24: return 16;
		case 25: return 144;
		case 26: return 144;
		case 27: return 832;
		case 28: return 176;
		case 29: return 4520;
		case 30: return 80;
		case 32: return 40;
		case 34: return 88;
		case 35: return 176;
		case 36: return 168;
		case 37: return 16;
		case 38: return 312;
		case 39: return 312;
		case 40: return 128;
		case 41: return 64;
		case 42: return 16;
		case 43: return 16;
		case 48: return 24;
		case 49: return 40;
		case 50: return 24;
		case 51: return 56;
		case 52: return 48;
		case 53: return 24;
		case 54: return 16;
		case 55: return 128;
		case 56: return 2704;
		case 57: return 136;
		case 58: return 32;
		case 59: return 24;
		case 60: return 112;
		case 61: return 112;
		case 62: return 48;
		case 63: return 120;
		case 64: return 192;
		case 65: return 184;
		case 66: return 32;
		case 67: return 704;
		case 68: return 3848;
		case 69: return 136;
		case 70: return 40;
		case 71: return 144;
		case 72: return 64;
		case 73: return 56;
		case 74: return 16;
		case 75: return 24;
		case 76: return 48;
		case 77: return 80;
		case 78: return 32;
		case 79: return 32;
		}

		throw std::exception("Invalid xasset type passed to GetXAssetTypeSize.");
	}

	// Links the provided asset, adding it to Parasyte's own internal lists.
	uint8_t* __fastcall LinkAsset(uint32_t xassetType, uint8_t** asset)
	{
		auto data = std::to_string((uint64_t)asset);
		auto name = GetXAssetName(xassetType, *asset);
		auto pool = &ps::Parasyte::GetCurrentHandler()->XAssetPools[xassetType];
		auto temp = name[0] == ',';
		auto capacity = 512;
		auto size = GetXAssetTypeSize(xassetType);

		// Add extra for images, as we append the streamed info to the end of the
		// image data.
		if (xassetType == 18)
		{
			size += sizeof(AssetFileRef) * 4;
		}

		// Ensure pool is initialized
		pool->Initialize(size, capacity);

		if (temp)
		{
			SetXAssetName(xassetType, *asset, name + 1);
			name = GetXAssetName(xassetType, *asset);
		}

		auto result = pool->LinkXAssetEntry(name, xassetType, size, temp, *asset, ps::Parasyte::GetCurrentFastFile());

		auto header = result->Header;

		// Loggary for Stiggary
		ps::log::Log(ps::LogType::Verbose, "%s Type: %i @ 0x%llx", name, xassetType, (uint64_t)result->Header);

		if (!temp)
		{
			switch (xassetType)
			{
			case 18:
			{
				// Check are we a streamed image, if we are, we need to grab the streaming
				// info that was loaded from the fast file's header. The game resolves this 
				// later so we must do it now.
				if (*(uint8_t*)(header + 57) != 0)
				{
					// No image table but we have images, so attempt locate from another image?
					// Haven't the slightest clue how the game accounts for this rn but we'll do it
					// like Harry's marriage.
					if (ImageCount == 0)
					{
						auto xasset = result->FindChildOfFastFile(ps::Parasyte::GetCurrentFastFile()->Parent);

						if (xasset != nullptr)
						{
							std::memcpy(
								header + 112 + sizeof(AssetFileRef),
								xasset->Header + 112 + sizeof(AssetFileRef),
								sizeof(AssetFileRef) * 4);
						}
					}
					else
					{
						for (size_t i = 0; i < 4; i++)
						{
							// Should never happen on a valid Fast File
							if (ImageIndex >= ImageCount)
								throw std::exception("Invalid image index, corrupt PAK table in fast file.");

							auto image = ImageBuffer[ImageIndex++];
							// Copy to end of the header so that tools can read directly from it
							std::memcpy(
								header + 112 + sizeof(AssetFileRef) * i,
								&image,
								sizeof(AssetFileRef));
							ps::log::Log(ps::LogType::Verbose, "Mip Map Pkg: %llu @ 0x%llx", (uint64_t)image.PackageIndex, image.StartOffset);
						}
					}
				}
				else if (*(uint64_t*)(header + 64) != 0)
				{
					result->ExtendedDataSize = *(uint32_t*)(header + 40);
					result->ExtendedData = std::make_unique<uint8_t[]>(result->ExtendedDataSize);
					result->ExtendedDataPtrOffset = 64;
					std::memcpy(result->ExtendedData.get(), *(void**)(header + 64), result->ExtendedDataSize);
					*(void**)(header + 64) = result->ExtendedData.get();
				}
				break;
			}
			}

		}

		return result->Header;
	}

	// Links xasset type 28 (bsp related, they do extended stuff so we must detour the entire function).
	void* __fastcall LinkXAsset28(uint8_t** a1)
	{
		*a1 = LinkAsset(28, a1);
		return *a1;
	}

	// Fixes up xmodel surface pointers within xmodels.
	__int64 __fastcall XModelSurfsFixup(__int64 a1)
	{
		__int16 v1; // r9
		int v3; // er10
		__int64 v5; // rax
		__int64 v6; // r8
		__int64 v7; // rcx

		*(uint32_t*)(a1 + 16) &= ~2u;
		v1 = 0;
		v3 = 0;
		if (*(char*)(a1 + 11) <= 0)
		{
			*(uint16_t*)(a1 + 26) = 0;
		}
		else
		{
			v5 = a1 + 244;
			do
			{
				v6 = *(uint64_t*)(v5 - 12);
				*(uint32_t*)(v5 - 4) = *(uint32_t*)(v6 + 20);
				*(uint32_t*)v5 = *(uint32_t*)(v6 + 24);
				*(uint32_t*)(v5 + 4) = *(uint32_t*)(v6 + 28);
				*(uint32_t*)(v5 + 8) = *(uint32_t*)(v6 + 32);
				*(uint32_t*)(v5 + 12) = *(uint32_t*)(v6 + 36);
				*(uint32_t*)(v5 + 16) = *(uint32_t*)(v6 + 40);
				*(uint32_t*)(v5 + 20) = *(uint32_t*)(v6 + 44);
				*(uint32_t*)(v5 + 24) = *(uint32_t*)(v6 + 48);
				*(uint64_t*)(v5 + 28) = *(uint64_t*)(v6 + 8);
				*(uint16_t*)(v5 - 16) = *(uint16_t*)(v6 + 16);
				v7 = *(uint64_t*)(v5 - 12);
				*(uint16_t*)(v5 - 14) = v1;
				++v3;
				v1 += *(uint16_t*)(v6 + 16);
				v5 += 64i64;
			} while (v3 < *(char*)(a1 + 11));
			*(uint16_t*)(a1 + 26) = v1;
		}

		return 0;
	}

	// Clears asset alignment data.
	void ClearAssetAlignment()
	{
		AssetAlignmentPointers[7] = &AssetAlignmentBuffer[24608];
		AssetAlignmentPointers[8] = &AssetAlignmentBuffer[0];

		std::memset((void*)AssetAlignmentBuffer, 0, (size_t)24608 * 2);
	}
}

const std::string ps::CoDIWHandler::GetName()
{
	return "Call of Duty: Infinite Warfare";
}

const bool ps::CoDIWHandler::GetFiles(const std::string& pattern, std::vector<std::string>& results)
{
	HANDLE findHandle;
	WIN32_FIND_DATA findData;

	auto fullPath = GameDirectory + "\\" + pattern + ".ff";
	findHandle = FindFirstFileA(fullPath.c_str(), &findData);

	if (findHandle != INVALID_HANDLE_VALUE)
	{
		do
		{
			std::string_view fileName = findData.cFileName;

			if (fileName.ends_with(".ff") &&
				fileName.find('\\') == std::string::npos &&
				fileName.find('/') == std::string::npos)
			{
				results.emplace_back(fileName.substr(0, fileName.find(".ff")));
			}
		} while (FindNextFileA(findHandle, &findData));

		FindClose(findHandle);
	}

	return true;
}

bool ps::CoDIWHandler::Initialize(const std::string& gameDirectory)
{
	GameDirectory = gameDirectory;

	//LoadConfigs("Data\\Configs\\CoDVGHandler.json");
	//SetConfig();

	ps::log::Log(ps::LogType::Normal, "Attempting to open game directory: %s...", GameDirectory.c_str());

	FileSystem = ps::FileSystem::Open(GameDirectory);

	ps::log::Log(ps::LogType::Verbose, "Using: %s for file system.", FileSystem->GetName());

	ps::log::Log(ps::LogType::Normal, "Attempting to initialize Call of Duty: Infinite Warfare....");
	ps::log::Log(ps::LogType::Normal, "Attempting to open directory: %s", gameDirectory.c_str());

	if (!std::filesystem::exists(gameDirectory))
	{
		ps::log::Log(ps::LogType::Error, "Failed to locate Call of Duty: Infinite Warfare Remastered's at: %s", gameDirectory.c_str());
		ps::log::Log(ps::LogType::Error, "Check to your path and if it has spaces, make sure to put it inside quotes.");
		ps::log::Log(ps::LogType::Error, "Check the wiki for examples on how to pass the game path correctly.");
		return false;
	}

	ps::log::Log(ps::LogType::Normal, "Successfully opened directory: %s", gameDirectory.c_str());

	if (!Module.Load("Data\\Dumps\\iw7_ship_dump.exe"))
	{
		ps::log::Log(ps::LogType::Error, "Failed to load Call of Duty: Infinite Warfares's Module: Data\\iw7_ship_dump.exe");
		ps::log::Log(ps::LogType::Error, "Please refer to the Wiki for information producing a game dump.");
		return false;
	}

	Module.LoadCache("Data\\Dumps\\iw7_ship_dump.cache");

	Pattern pattern;

	pattern.Update("E8 ?? ?? ?? 00 EB 05 E8 ?? ?? ?? 00 8B D8 83");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::ParseFastFile,
		pattern,
		8,
		"IW7::Var0",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("E8 ?? ?? ?? 00 E8 ?? ?? ?? FF 80 3D ?? ?? ?? ?? 00 74 05 E8");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::AssignMemoryPointers,
		pattern,
		1,
		"IW7::Var1",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("00 E8 ?? ?? ?? FF 80 3D ?? ?? ?? ?? 00 74 05 E8");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::AssetAlignmentInit,
		pattern,
		2,
		"IW7::Var2",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("0F ?? ?? 11 48 ?? ?? E8 ?? ?? ?? ?? BA 04 00 00 00 48");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::GetXAssetName,
		pattern,
		8,
		"IW8::Var3",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("4C ?? ?? B9 12 00 00 00 E8 ?? ?? ?? 00 48");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::SetXAssetName,
		pattern,
		9,
		"IW8::Var4",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("CE 4C 8D 3D ?? ?? ?? ?? E8 ?? ?? ?? ?? 4D 8B 04");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::GetXAssetPoolSize,
		pattern,
		9,
		"IW8::Var5",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("48 C7 02 00 00 00 00 48 ?? ?? 48 8B 05 ?? ?? ?? ?? 48 8B F9");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::GraphicsDvar,
		pattern,
		13,
		"IW8::Var6",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("48 8D 35 ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 44 8B DA");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::AssetAlignmentPointers,
		pattern,
		3,
		"IW8::Var7",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("48 8D 15 ?? ?? ?? ?? 3D FF FF FF 7F 74");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::AssetAlignmentBuffer,
		pattern,
		3,
		"IW8::Var8",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("48 8D ?? ?? 20 89 ?? ?? 20 E8 ?? ?? ?? ?? 48 ?? C4");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::AssetAlignmentOnAssetLink,
		pattern,
		10,
		"IW7::Var9",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("B1 01 48 89 05 ?? ?? ?? ?? E8 ?? ?? ?? ?? E8");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::LoadXAssetHeader,
		pattern,
		10,
		"IW7::Var9",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("48 C1 E1 04 48 03 48 18 48 89 0D ?? ?? ?? ?? 33 C9 E8");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::VarXAssetHeader,
		pattern,
		11,
		"IW7::Var10",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("39 9F 18 01 00 00 76 ?? E8 ?? ?? ?? ?? B1 01 48");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::AllocXAssetHeader,
		pattern,
		9,
		"IW7::Var11",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("41 B8 A8 11 00 00 0F B6 CB E8 ?? ?? ?? ?? B9 08 00 00 00 E8");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::PushZoneBlock,
		pattern,
		20,
		"IW7::Var12",
		ps::ScanType::FromEndOfData)) return false;
	pattern.Update("E8 ?? ?? ?? ?? 8B C3 48 8D 0C 40 48 8B 87 10 01 00 00 48");
	if (!Module.FindVariableAddress(
		&ps::CoDIWInternal::PopZoneBlock,
		pattern,
		1,
		"IW7::Var13",
		ps::ScanType::FromEndOfData)) return false;

	pattern.Update("28 00 00 00 48 ?? ?? E8 ?? ?? ?? ?? ?? 08 00 00 00 E8");
	if (!Module.CreateDetour((uintptr_t)Module.FindVariableAddress(
		pattern,
		8,
		"IW7::Det0",
		ps::ScanType::FromEndOfData), (uintptr_t)&ps::CoDIWInternal::ReadXFile)) return false;
	pattern.Update("74 ?? ?? 04 00 00 00 E8 ?? ?? ?? 00 48 ?? ?? 48");
	if (!Module.CreateDetour((uintptr_t)Module.FindVariableAddress(
		pattern,
		8,
		"IW7::Det1",
		ps::ScanType::FromEndOfData), (uintptr_t)&ps::CoDIWInternal::AllocateString)) return false;
	pattern.Update("B9 47 00 00 00 E8 ?? ?? ?? 00 48 ?? ?? E8");
	if (!Module.CreateDetour((uintptr_t)Module.FindVariableAddress(
		pattern,
		6,
		"IW7::Det2",
		ps::ScanType::FromEndOfData), (uintptr_t)&ps::CoDIWInternal::LinkAsset)) return false;
	pattern.Update("40 57 48 ?? ?? 20 48 ?? ?? 48 8D ?? ?? 30 48 8B F9 48 ?? ?? ?? 30 B9 1C 00 00 00 E8 ?? ?? ?? ?? 48");
	if (!Module.CreateDetour((uintptr_t)Module.FindVariableAddress(
		pattern,
		0,
		"IW7::Det3",
		ps::ScanType::NoResolving), (uintptr_t)&ps::CoDIWInternal::LinkXAsset28)) return false;

	pattern.Update("48 ?? ?? 18 44 ?? 02 48 ?? ?? 08 E8 ?? ?? ?? 00 48");
	if(!Module.NullifyFunction(
		pattern,
		12,
		"IW7::Null0",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 20 44 ?? ?? 04 48 ?? ?? 10 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		13,
		"IW7::Null1",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 50 33 D2 45 ?? ?? 28 4D ?? ?? 38 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		15,
		"IW7::Null2",
		true,
		true)) return false;
	pattern.Update("B9 47 00 00 00 E8 ?? ?? ?? 00 48 ?? ?? E8");
	if (!Module.NullifyFunction(
		pattern,
		14,
		"IW7::Null3",
		true,
		true)) return false;
	pattern.Update("E8 ?? ?? ?? 00 48 8B 1D ?? ?? ?? ?? 41 B8 08 00");
	if (!Module.NullifyFunction(
		pattern,
		1,
		"IW7::Null4",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 30 44 ?? ?? C0 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null5",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 28 44 ?? ?? 40 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null6",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 28 44 ?? ?? 40 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null6",
		true,
		true)) return false;
	pattern.Update("44 ?? ?? 18 48 ?? ?? 50 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null7",
		true,
		true)) return false;
	pattern.Update("4C ?? ?? 50 48 ?? ?? 58 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null8",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 68 41 ?? ?? 03 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null9",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 70 41 ?? ?? 03 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null10",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 90 00 00 00 41 ?? ?? 05 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		12,
		"IW7::Null11",
		true,
		true)) return false;
	pattern.Update("48 ?? ?? 98 00 00 00 41 ?? ?? 05 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		12,
		"IW7::Null12",
		true,
		true)) return false;
	pattern.Update("30 B9 40 00 00 00 E8 F0 D8 6B 00 48");
	if (!Module.NullifyFunction(
		pattern,
		15,
		"IW7::Null13",
		true,
		true)) return false;
	pattern.Update("30 B9 40 00 00 00 E8 F0 D8 6B 00 48");
	if (!Module.NullifyFunction(
		pattern,
		25,
		"IW7::Null14",
		true,
		true)) return false;
	pattern.Update("30 B9 40 00 00 00 E8 F0 D8 6B 00 48");
	if (!Module.NullifyFunction(
		pattern,
		25,
		"IW7::Null15",
		true,
		true)) return false;
	pattern.Update("30 B9 40 00 00 00 E8 F0 D8 6B 00 48");
	if (!Module.NullifyFunction(
		pattern,
		44,
		"IW7::Null16",
		true,
		true)) return false;
	pattern.Update("30 B9 40 00 00 00 E8 F0 D8 6B 00 48");
	if (!Module.NullifyFunction(
		pattern,
		52,
		"IW7::Null17",
		true,
		true)) return false;
	pattern.Update("08 75 09 49 8B 0C 87 E8 43 00 00 00 49 8B C4");
	if (!Module.NullifyFunction(
		pattern,
		8,
		"IW7::Null18",
		true,
		true)) return false;
	pattern.Update("41 B8 18 00 00 00 33 C9 E8 ?? ?? ?? ?? 48 8B CB E8");
	if (!Module.NullifyFunction(
		pattern,
		17,
		"IW7::Null19",
		true,
		true)) return false;
	pattern.Update("48 8B 52 58 C1 E0 05 89 44 24 20 E8 ?? ?? ?? ?? 48");
	if (!Module.NullifyFunction(
		pattern,
		12,
		"IW7::Null20",
		true,
		true)) return false;
	pattern.Update("4D 8B 40 50 41 C1 E1 05 E8 ?? ?? ?? ?? 48");
	if (!Module.NullifyFunction(
		pattern,
		9,
		"IW7::Null21",
		true,
		true)) return false;
	pattern.Update("41 ?? ?? 00 20 00 00 48 ?? ?? 18 41 ?? ?? 06 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		16,
		"IW7::Null22",
		true,
		true)) return false;
	pattern.Update("48 8B 15 ?? ?? ?? ?? 49 8D 4E 20 48 8B 52 20 E8 ?? ?? ?? 00 48");
	if (!Module.NullifyFunction(
		pattern,
		16,
		"IW7::Null23",
		true,
		true)) return false;
	pattern.Update("B9 14 00 00 00 E8 ?? ?? ?? ?? 48 89 03 48 8B C8 0F B6 15 ?? ?? ?? ?? E8");
	if (!Module.NullifyFunction(
		pattern,
		24,
		"IW7::Null24",
		true,
		true)) return false;
	pattern.Update("48 81 C3 08 01 00 00 48 ?? ?? 48 89 1D ?? ?? ?? ?? 33 C9");
	if (!Module.NullifyFunction(
		pattern,
		35,
		"IW7::Null25",
		true,
		true)) return false;
	pattern.Update("44 8B 40 08 E8 ?? ?? ?? ?? 48 8B 15 ?? ?? ?? ?? 48 8B CF E8");
	if (!Module.NullifyFunction(
		pattern,
		20,
		"IW7::Null26",
		true,
		true)) return false;;

	*ps::CoDIWInternal::GraphicsDvar = ps::CoDIWInternal::GraphicsDvarBuffer;

	GameDirectory = gameDirectory;

	XAssetPoolCount   = 256;
	XAssetPools       = std::make_unique<XAssetPool[]>(XAssetPoolCount);
	Strings           = std::make_unique<char[]>(0x2000000);
	StringPoolSize    = 0;
	Initialized       = true;
	StringLookupTable = std::make_unique<std::map<uint64_t, size_t>>();

	Module.SaveCache("Data\\Dumps\\iw7_ship_dump.cache");
#if _DEBUG
	LoadAliases("F:\\Data\\VisualStudio\\Projects\\HydraX\\src\\HydraX\\bin\\x64\\Debug\\exported_files\\InfiniteWarfareAliases.json");
#else
	LoadAliases("Data\\InfiniteWarfareAliases.json");
#endif

	return true;
}

bool ps::CoDIWHandler::Uninitialize()
{
	Module.Free();
	XAssetPoolCount   = 256;
	XAssetPools       = nullptr;
	Strings           = nullptr;
	StringPoolSize    = 0;
	Initialized       = false;
	StringLookupTable = nullptr;
	GameDirectory.clear();

	// Clear out open handles to reference files.
	for(size_t i = 0; i < ps::CoDIWInternal::AssetPacks.size(); i++)
	{
		if (ps::CoDIWInternal::AssetPacks[i] != NULL && ps::CoDIWInternal::AssetPacks[i] != INVALID_HANDLE_VALUE)
		{
			CloseHandle(ps::CoDIWInternal::AssetPacks[i]);
			ps::CoDIWInternal::AssetPacks[i] = NULL;
		}
	}

	return true;
}

bool ps::CoDIWHandler::IsValid(const std::string& param)
{
	return strcmp(param.c_str(), "iw") == 0;
}


bool ps::CoDIWHandler::ListFiles()
{
	std::vector<std::string> files;
	GetFiles("*", files);
	ps::log::Log(ps::LogType::Normal, "Listing files from: %s", GetName().c_str());

	for (auto& file : files)
	{
		ps::log::Log(ps::LogType::Normal, "File: %s Available: 1", file.c_str());
	}

	ps::log::Log(ps::LogType::Normal, "Listed: %lu files.", files.size());

	return true;
}

bool ps::CoDIWHandler::Exists(const std::string& ffName)
{
	if (!Initialized)
	{
		return false;
	}

	return std::filesystem::exists(GameDirectory + "\\" + ffName + ".ff");
}

bool ps::CoDIWHandler::LoadFastFile(const std::string& ffName, FastFile* parent, BitFlags<FastFileFlags> flags)
{
	auto newFastFile = CreateUniqueFastFile(ffName);

	newFastFile->Parent = parent;
	newFastFile->Flags = flags;

	// Set current ff for loading purposes.
	ps::Parasyte::PushTelemtry("LastFastFileName", ffName);
	ps::Parasyte::SetCurrentFastFile(newFastFile);

	ps::FileHandle ffHandle(FileSystem->OpenFile(GetFileName(ffName + ".ff"), "r"), FileSystem.get());
	ps::FileHandle fpHandle(FileSystem->OpenFile(GetFileName(ffName + ".fp"), "r"), FileSystem.get());

	if (!ffHandle.IsValid())
	{
		ps::log::Log(ps::LogType::Error, "The provided fast file could not be found in the game's file system.");
		ps::log::Log(ps::LogType::Error, "Make sure any updates are finished and check for any content packages.");

		throw std::exception("Could not open the fast file from the game's file system.");
	}

	bool success = true;

	auto magic = ffHandle.Read<uint64_t>();
	auto version = ffHandle.Read<uint32_t>();

	if (magic != 0x3030313066665749 && magic != 0x3030317566665749)
		throw std::exception("Invalid fast file magic number.");
	if (version != 0x653)
		throw std::exception("Invalid fast file version.");


	// TODO: We're making assumptions about PC fast files, these flags
	// contain information such as encryption, compression, etc. but in all
	// cases atm they are constant.
	auto flag0 = ffHandle.Read<uint8_t>();
	auto flag1 = ffHandle.Read<uint8_t>();
	auto flag2 = ffHandle.Read<uint8_t>();
	auto flag3 = ffHandle.Read<uint8_t>();
	auto padd0 = ffHandle.Read<uint64_t>();
	auto sizes = ffHandle.Read<ps::CoDIWInternal::BufferSizes>();

	// Read streamed data sizes, we need the asset file and image file information.
	auto b0 = (size_t)ffHandle.Read<uint32_t>();
	auto b1 = (size_t)ffHandle.Read<uint32_t>();
	auto b2 = (size_t)ffHandle.Read<uint32_t>();
	auto b3 = (size_t)ffHandle.Read<uint32_t>();

	auto assetFileBuffer = ffHandle.ReadArray<ps::CoDIWInternal::AssetFileRef>(b1);
	auto imageFileBuffer = ffHandle.ReadArray<ps::CoDIWInternal::AssetFileRef>(b3);

	// Sometimes these are 0? Not of use it seems for us, simply for
	// the game internally for allocating memory.
	auto totalSize = ffHandle.Read<uint64_t>();
	auto authSize = ffHandle.Read<uint64_t>();
	auto actualSize = ffHandle.Read<uint64_t>();

	for (size_t i = 0; i < 10; i++)
	{
		if (sizes.DataSizes[i] > 0)
		{
			ps::log::Log(ps::LogType::Verbose, "Allocating block: %llu of size: 0x%llx for file: %s", i, sizes.DataSizes[i], ffName.c_str());
			ps::Parasyte::GetCurrentFastFile()->MemoryBlocks[i].Initialize(sizes.DataSizes[i], 0x1000);
		}
	}

	ps::CoDIWInternal::AssignMemoryPointers(&ps::Parasyte::GetCurrentFastFile()->MemoryBlocks[0]);
	ps::CoDIWInternal::ClearAssetAlignment();
	ps::CoDIWInternal::AssetAlignmentInit();

	// Check if we have asset data, the way IW works, we load from these first before
	// the fast file actually loads, it seems to be mostly xmodel meshes so it must be
	// used to allow sharing of asset buffers across maps.
	if (b1 > 0)
	{
		ps::CoDIWInternal::PushZoneBlock(8);

		for (size_t i = 0; i < b1; i++)
		{
			auto& assetFileRef = assetFileBuffer[i];
			ps::log::Log(ps::LogType::Verbose, "Loading asset reference: %i in asset file: %i...", i, assetFileRef.PackageIndex);

			ps::FileHandle assetFileHandle(FileSystem->OpenFile("assetfile" + std::to_string(assetFileRef.PackageIndex) + ".pak", "r"), FileSystem.get());

			if (!assetFileHandle.IsValid())
				ps::log::Log(ps::LogType::Error, "Failed to find asset file index: %i", assetFileRef.PackageIndex);

			ps::CoDIWInternal::FFDecompressor = std::make_unique<LZ4DecompressorV2>(assetFileHandle, assetFileHandle.Read<uint64_t>() == 0x3030313066665749);

			assetFileHandle.Seek(assetFileBuffer[i].StartOffset, FILE_BEGIN);

			*ps::CoDIWInternal::VarXAssetHeader = ps::CoDIWInternal::AllocXAssetHeader();
			ps::CoDIWInternal::LoadXAssetHeader(1);
			ps::CoDIWInternal::PopZoneBlock();

			ps::log::Log(ps::LogType::Verbose, "Successfully loaded asset reference: %i in asset file: %i", i, assetFileRef.PackageIndex);
		}
	}


	ps::CoDIWInternal::FFDecompressor = std::make_unique<LZ4DecompressorV2>(ffHandle, magic == 0x3030313066665749);
	ps::CoDIWInternal::FPDecompressor = std::make_unique<LZ4DecompressorV2>(fpHandle, magic == 0x3030313066665749);

	// Now we can set up our fast file, secure means we have hash blocks.
	ps::CoDIWInternal::ImageIndex = 0;
	ps::CoDIWInternal::ImageCount = b3;
	ps::CoDIWInternal::ImageBuffer = imageFileBuffer.get();
	ps::CoDIWInternal::ParseFastFile(nullptr, ps::Parasyte::GetCurrentFastFile()->AssetList, ffName.c_str(), 0);

	// We must fix up any XModel surfs, as we may have overrode previous
	// temporary entries, etc.
	ps::Parasyte::GetCurrentHandler()->XAssetPools[8].EnumerateEntries([](ps::XAsset* asset)
	{
		ps::CoDIWInternal::XModelSurfsFixup((__int64)asset->Header);
	});

	ps::log::Log(ps::LogType::Normal, "Successfully loaded: %s", ffName.c_str());

	// If we have no parent, we are a root, and need to attempt to load the localized, etc.
	if (success && newFastFile->Parent == nullptr && !flags.HasFlag(ps::FastFileFlags::NoChildren))
	{
		auto techsetsName = "techsets_" + ffName;
		auto patchName = "patch_" + ffName;

		// Attempt to load the techsets file, this usually contains
		// materials, shaders, technique sets, etc.
		if (Exists(techsetsName) && !IsFastFileLoaded(techsetsName))
			LoadFastFile(techsetsName, newFastFile, flags);
		if (Exists(patchName) && !IsFastFileLoaded(patchName))
			LoadFastFile(patchName, newFastFile, flags);

		// Check for locale prefix
		if (RegionPrefix.size() > 0)
		{
			auto localeName      = RegionPrefix + ffName;
			auto localePatchName = RegionPrefix + "patch_" + ffName;

			// Now load the locale, not as important, as usually
			// only contains localized data.
			if(Exists(localeName) && !IsFastFileLoaded(localeName))
				LoadFastFile(localeName, newFastFile, flags);
			if (Exists(localePatchName) && !IsFastFileLoaded(localePatchName))
				LoadFastFile(localePatchName, newFastFile, flags);
		}
	}

	return true;
}

bool ps::CoDIWHandler::CleanUp()
{
	return true;
}

const std::string ps::CoDIWHandler::GetShorthand()
{
	return "iw";
}

PS_CINIT(ps::GameHandler, ps::CoDIWHandler, ps::GameHandler::GetHandlers());
#endif