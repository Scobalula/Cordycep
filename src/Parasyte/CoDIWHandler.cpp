#include "pch.h"
#if _WIN64
#include "Parasyte.h"
#include "CoDIWHandler.h"
#include "lz4.h"
#include "LZ4DecompressorV2.h"

// Internal
namespace ps::CoDIWInternal
{
	// The fast file decompressor.
	std::unique_ptr<Decompressor> FFDecompressor;
	// The patch file decompressor.
	std::unique_ptr<Decompressor> FPDecompressor;

	// The xasset buffer sizes definition.
	struct BufferSizes
	{
		uint64_t     Unk[3];
		uint64_t     DataSizes[18];
	};
	// The asset file reference definition.
	struct AssetFileRef
	{
		uint64_t StartOffset;
		uint64_t EndOffset;
		uint16_t PackageIndex;
	};
	// Sound Files
	std::array<HANDLE, 512> AssetPacks;

	// Blank Graphics Dvar Buffer
	char GraphicsDvarBuffer[512]{};
	// Graphics Related Dvar
	char** GraphicsDvar = nullptr;
	// Current Images Index.
	size_t ImageIndex = 0;
	// Current Images Count.
	size_t ImageCount = 0;
	// Current Images Buffer.
	AssetFileRef* ImageBuffer = nullptr;

	// A list of pointers for each buffer.
	uint8_t** AssetAlignmentPointers = nullptr;
	// A list of offsets for each buffer.
	uint8_t* AssetAlignmentBuffer = nullptr;
	// The current xasset header being read.
	void** VarXAssetHeader = nullptr;
	// The current zone loader mode.
	uint8_t* ZoneLoader_Mode = nullptr;


	// The function to handle parsing the fast file within the game's exe.
	void* (__cdecl* ParseFastFile)(const void* unk1, const char* AssetList, const char* name, bool unk);
	// The function to handle assigning the memory pointers
	void(__cdecl* AssignMemoryPointers)(void* blocks);
	// The function to handle initializing asset alignment.
	void(__cdecl* AssetAlignmentInit)();
	// The function to handle on asset link.
	void(__cdecl* AssetAlignmentOnAssetLink)();
	// The function to handle getting the asset name.
	const char* (__fastcall* GetXAssetName)(uint32_t assetType, void* xassetHeader);
	// The function to handle setting the asset name.
	const char* (__fastcall* SetXAssetName)(uint32_t assetType, void* xassetHeader, const char* name);
	// The function to handle getting the asset size.
	const size_t(__fastcall* GetXAssetPoolSize)(uint32_t xassetType);

	// The function to handle reading a single xasset header and its data.
	void* (__fastcall* AllocXAssetHeader)();
	// The function to handle reading a single xasset header and its data.
	void* (__fastcall* LoadXAssetHeader)(uint32_t atStreamStart);
	// The function to handle reseting the db pointers.
	void(__fastcall* PushZoneBlock)(uint32_t index);
	// The function to handle reseting the db pointers.
	void(__fastcall* PopZoneBlock)();

	// Requests a handle to an asset file for use with shared data loading.
	HANDLE AssetFile_RequestFile(uint16_t index)
	{
		ps::log::Log(ps::LogType::Verbose, "Requesting asset file index: %i", index);

		HANDLE handle = AssetPacks[index];

		if (handle == NULL)
		{
			auto soundFilePath = ps::Parasyte::GetCurrentHandler()->GameDirectory + "\\" + "assetfile" + std::to_string(index) + ".pak";

			ps::log::Log(ps::LogType::Verbose, "Asset file not open. Attempting to open asset file: %s", soundFilePath.c_str());

			AssetPacks[index] = CreateFileA(
				soundFilePath.c_str(),
				FILE_READ_DATA | FILE_READ_ATTRIBUTES,
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL,
				OPEN_EXISTING,
				0,
				NULL);

			handle = AssetPacks[index];
		}

		return handle;
	}

	// Reads compressed data from the file.
	void ReadXFile(void* ptr, size_t size)
	{
		FFDecompressor->Read(ptr, size, 0);
	}

	// Allocates a string entry within our handler.
	__int64 AllocateString(const char* str, unsigned int user)
	{
		auto strLen = strlen(str) + 1;
		auto id = XXHash64::hash(str, strLen, 0);
		auto potentialEntry = ps::Parasyte::GetCurrentHandler()->StringLookupTable->find(id);

		if (potentialEntry != ps::Parasyte::GetCurrentHandler()->StringLookupTable->end())
		{
			return (int)potentialEntry->second;
		}

		auto offset = ps::Parasyte::GetCurrentHandler()->StringPoolSize;
		std::memcpy(&ps::Parasyte::GetCurrentHandler()->Strings[offset], str, strLen);
		ps::Parasyte::GetCurrentHandler()->StringPoolSize += strLen;
		ps::Parasyte::GetCurrentHandler()->StringLookupTable->operator[](id) = offset;

		return offset;
	}

	// Gets the size of the xasset header for the given type.
	size_t GetXAssetTypeSize(const size_t type)
	{
		// Autogenerated! DO NOT EDIT!
		switch (type)
		{
		case 0: return 24;
		case 1: return 32;
		case 2: return 32;
		case 3: return 80;
		case 4: return 32;
		case 5: return 24;
		case 6: return 136;
		case 7: return 56;
		case 8: return 736;
		case 9: return 80;
		case 10: return 280;
		case 11: return 40;
		case 12: return 40;
		case 13: return 40;
		case 14: return 40;
		case 15: return 40;
		case 16: return 2280;
		case 17: return 56;
		case 18: return 112;
		case 19: return 208;
		case 20: return 352;
		case 21: return 24;
		case 22: return 384;
		case 23: return 104;
		case 24: return 16;
		case 25: return 144;
		case 26: return 144;
		case 27: return 832;
		case 28: return 176;
		case 29: return 4520;
		case 30: return 80;
		case 32: return 40;
		case 34: return 88;
		case 35: return 176;
		case 36: return 168;
		case 37: return 16;
		case 38: return 312;
		case 39: return 312;
		case 40: return 128;
		case 41: return 64;
		case 42: return 16;
		case 43: return 16;
		case 48: return 24;
		case 49: return 40;
		case 50: return 24;
		case 51: return 56;
		case 52: return 48;
		case 53: return 24;
		case 54: return 16;
		case 55: return 128;
		case 56: return 2704;
		case 57: return 136;
		case 58: return 32;
		case 59: return 24;
		case 60: return 112;
		case 61: return 112;
		case 62: return 48;
		case 63: return 120;
		case 64: return 192;
		case 65: return 184;
		case 66: return 32;
		case 67: return 704;
		case 68: return 3848;
		case 69: return 136;
		case 70: return 40;
		case 71: return 144;
		case 72: return 64;
		case 73: return 56;
		case 74: return 16;
		case 75: return 24;
		case 76: return 48;
		case 77: return 80;
		case 78: return 32;
		case 79: return 32;
		}

		throw std::exception("Invalid xasset type passed to GetXAssetTypeSize.");
	}

	// Links the provided asset, adding it to Parasyte's own internal lists.
	uint8_t* __fastcall LinkAsset(uint32_t xassetType, uint8_t** asset)
	{
		auto data = std::to_string((uint64_t)asset);
		auto name = GetXAssetName(xassetType, *asset);
		auto pool = &ps::Parasyte::GetCurrentHandler()->XAssetPools[xassetType];
		auto temp = name[0] == ',';
		auto capacity = 512;
		auto size = GetXAssetTypeSize(xassetType);

		// Add extra for images, as we append the streamed info to the end of the
		// image data.
		if (xassetType == 18)
		{
			size += sizeof(AssetFileRef) * 4;
		}

		// Ensure pool is initialized
		pool->Initialize(size, capacity);

		if (temp)
		{
			SetXAssetName(xassetType, *asset, name + 1);
			name = GetXAssetName(xassetType, *asset);
		}

		auto result = pool->LinkXAssetEntry(name, xassetType, size, temp, *asset, ps::Parasyte::GetCurrentFastFile());

		auto header = result->Header;

		// Loggary for Stiggary
		ps::log::Log(ps::LogType::Verbose, "%s Type: %i @ 0x%llx", name, xassetType, (uint64_t)result->Header);

		if (!temp)
		{
			switch (xassetType)
			{
			case 18:
			{
				// Check are we a streamed image, if we are, we need to grab the streaming
				// info that was loaded from the fast file's header. The game resolves this 
				// later so we must do it now.
				if (*(uint8_t*)(header + 57) != 0)
				{
					// No image table but we have images, so attempt locate from another image?
					// Haven't the slightest clue how the game accounts for this rn but we'll do it
					// like Harry's marriage.
					if (ImageCount == 0)
					{
						auto xasset = result->FindChildOfFastFile(ps::Parasyte::GetCurrentFastFile()->Parent);

						if (xasset != nullptr)
						{
							std::memcpy(
								header + 112 + sizeof(AssetFileRef),
								xasset->Header + 112 + sizeof(AssetFileRef),
								sizeof(AssetFileRef) * 4);
						}
					}
					else
					{
						for (size_t i = 0; i < 4; i++)
						{
							// Should never happen on a valid Fast File
							if (ImageIndex >= ImageCount)
								throw std::exception("Invalid image index, corrupt PAK table in fast file.");

							auto image = ImageBuffer[ImageIndex++];
							// Copy to end of the header so that tools can read directly from it
							std::memcpy(
								header + 112 + sizeof(AssetFileRef) * i,
								&image,
								sizeof(AssetFileRef));
							ps::log::Log(ps::LogType::Verbose, "Mip Map Pkg: %llu @ 0x%llx", (uint64_t)image.PackageIndex, image.StartOffset);
						}
					}
				}
				else if (*(uint64_t*)(header + 64) != 0)
				{
					result->ExtendedDataSize = *(uint32_t*)(header + 40);
					result->ExtendedData = std::make_unique<uint8_t[]>(result->ExtendedDataSize);
					result->ExtendedDataPtrOffset = 64;
					std::memcpy(result->ExtendedData.get(), *(void**)(header + 64), result->ExtendedDataSize);
					*(void**)(header + 64) = result->ExtendedData.get();
				}
				break;
			}
			}

		}

		return result->Header;
	}

	// Links xasset type 28 (bsp related, they do extended stuff so we must detour the entire function).
	void* __fastcall LinkXAsset28(uint8_t** a1)
	{
		*a1 = LinkAsset(28, a1);
		return *a1;
	}

	// Fixes up xmodel surface pointers within xmodels.
	__int64 __fastcall XModelSurfsFixup(__int64 a1)
	{
		__int16 v1; // r9
		int v3; // er10
		__int64 v5; // rax
		__int64 v6; // r8
		__int64 v7; // rcx

		*(uint32_t*)(a1 + 16) &= ~2u;
		v1 = 0;
		v3 = 0;
		if (*(char*)(a1 + 11) <= 0)
		{
			*(uint16_t*)(a1 + 26) = 0;
		}
		else
		{
			v5 = a1 + 244;
			do
			{
				v6 = *(uint64_t*)(v5 - 12);
				*(uint32_t*)(v5 - 4) = *(uint32_t*)(v6 + 20);
				*(uint32_t*)v5 = *(uint32_t*)(v6 + 24);
				*(uint32_t*)(v5 + 4) = *(uint32_t*)(v6 + 28);
				*(uint32_t*)(v5 + 8) = *(uint32_t*)(v6 + 32);
				*(uint32_t*)(v5 + 12) = *(uint32_t*)(v6 + 36);
				*(uint32_t*)(v5 + 16) = *(uint32_t*)(v6 + 40);
				*(uint32_t*)(v5 + 20) = *(uint32_t*)(v6 + 44);
				*(uint32_t*)(v5 + 24) = *(uint32_t*)(v6 + 48);
				*(uint64_t*)(v5 + 28) = *(uint64_t*)(v6 + 8);
				*(uint16_t*)(v5 - 16) = *(uint16_t*)(v6 + 16);
				v7 = *(uint64_t*)(v5 - 12);
				*(uint16_t*)(v5 - 14) = v1;
				++v3;
				v1 += *(uint16_t*)(v6 + 16);
				v5 += 64i64;
			} while (v3 < *(char*)(a1 + 11));
			*(uint16_t*)(a1 + 26) = v1;
		}

		return 0;
	}

	// Clears asset alignment data.
	void ClearAssetAlignment()
	{
		AssetAlignmentPointers[7] = &AssetAlignmentBuffer[24608];
		AssetAlignmentPointers[8] = &AssetAlignmentBuffer[0];

		std::memset((void*)AssetAlignmentBuffer, 0, (size_t)24608 * 2);
	}
}

const std::string ps::CoDIWHandler::GetName()
{
	return "Call of Duty: Infinite Warfare";
}

bool ps::CoDIWHandler::GetFiles(const std::string& pattern, std::vector<std::string>& results)
{
	HANDLE findHandle;
	WIN32_FIND_DATA findData;

	auto fullPath = GameDirectory + "/" + pattern + ".ff";
	findHandle = FindFirstFileA(fullPath.c_str(), &findData);

	if (findHandle != INVALID_HANDLE_VALUE)
	{
		do
		{
			std::string_view fileName = findData.cFileName;

			if (fileName.ends_with(".ff") &&
				fileName.find('\\') == std::string::npos &&
				fileName.find('/') == std::string::npos)
			{
				results.emplace_back(fileName.substr(0, fileName.find(".ff")));
			}
		} while (FindNextFileA(findHandle, &findData));

		FindClose(findHandle);
	}

	return true;
}

const std::vector<std::string>& ps::CoDIWHandler::GetCommonFileNames() const
{
	static std::vector<std::string> results
	{
		"code_pre_gfx",
		"code_post_gfx",
		"global",
		"global_sp",
		"global_mp",
		"global_core_mp",
		"common",
		"common_sp",
		"common_mp",
		"common_core_mp",
	};

	return results;
}

bool ps::CoDIWHandler::Initialize(const std::string& gameDirectory)
{
	Configs.clear();
	GameDirectory = gameDirectory;

	if (!LoadConfigs("CoDIWHandler"))
	{
		return false;
	}

	SetConfig();
	CopyDependencies();
	OpenGameDirectory(GameDirectory);
	OpenGameModule(CurrentConfig->ModuleName);

	Module.LoadCache(CurrentConfig->CacheName);

	ResolvePatterns();

	PS_SETGAMEVAR(ps::CoDIWInternal::ParseFastFile);
	PS_SETGAMEVAR(ps::CoDIWInternal::AssignMemoryPointers);
	PS_SETGAMEVAR(ps::CoDIWInternal::AssetAlignmentInit);
	PS_SETGAMEVAR(ps::CoDIWInternal::GetXAssetName);
	PS_SETGAMEVAR(ps::CoDIWInternal::SetXAssetName);
	PS_SETGAMEVAR(ps::CoDIWInternal::GetXAssetPoolSize);
	PS_SETGAMEVAR(ps::CoDIWInternal::GraphicsDvar);
	PS_SETGAMEVAR(ps::CoDIWInternal::AssetAlignmentPointers);
	PS_SETGAMEVAR(ps::CoDIWInternal::AssetAlignmentBuffer);
	PS_SETGAMEVAR(ps::CoDIWInternal::AssetAlignmentOnAssetLink);
	PS_SETGAMEVAR(ps::CoDIWInternal::LoadXAssetHeader);
	PS_SETGAMEVAR(ps::CoDIWInternal::VarXAssetHeader);
	PS_SETGAMEVAR(ps::CoDIWInternal::AllocXAssetHeader);
	PS_SETGAMEVAR(ps::CoDIWInternal::PushZoneBlock);
	PS_SETGAMEVAR(ps::CoDIWInternal::PopZoneBlock);

	PS_DETGAMEVAR(ps::CoDIWInternal::ReadXFile);
	PS_DETGAMEVAR(ps::CoDIWInternal::AllocateString);
	PS_DETGAMEVAR(ps::CoDIWInternal::LinkAsset);
	PS_DETGAMEVAR(ps::CoDIWInternal::LinkXAsset28);

	*ps::CoDIWInternal::GraphicsDvar = ps::CoDIWInternal::GraphicsDvarBuffer;

	XAssetPoolCount   = 256;
	XAssetPools       = std::make_unique<XAssetPool[]>(XAssetPoolCount);
	Strings           = std::make_unique<char[]>(0x2000000);
	StringPoolSize    = 0;
	Initialized       = true;
	StringLookupTable = std::make_unique<std::map<uint64_t, size_t>>();

	Module.SaveCache(CurrentConfig->CacheName);
// #if _DEBUG
// 	LoadAliases("F:\\Data\\VisualStudio\\Projects\\HydraX\\src\\HydraX\\bin\\x64\\Debug\\exported_files\\InfiniteWarfareAliases.json");
// #else
// 	LoadAliases("Data\\InfiniteWarfareAliases.json");
// #endif
	// LoadAliases(CurrentConfig->AliasesName);

	return true;
}

bool ps::CoDIWHandler::Deinitialize()
{
	Module.Free();
	XAssetPoolCount   = 256;
	XAssetPools       = nullptr;
	Strings           = nullptr;
	StringPoolSize    = 0;
	Initialized       = false;
	StringLookupTable = nullptr;
	FileSystem        = nullptr;
	GameDirectory.clear();

	// Clear out open handles to reference files.
	for (auto& AssetPack : ps::CoDIWInternal::AssetPacks)
	{
		if (AssetPack != NULL && AssetPack != INVALID_HANDLE_VALUE)
		{
			CloseHandle(AssetPack);
			AssetPack = NULL;
		}
	}

	return true;
}

bool ps::CoDIWHandler::IsValid(const std::string& param)
{
	return strcmp(param.c_str(), "iw") == 0;
}

// TODO:
// bool ps::CoDIWHandler::ListFiles()
// {
// 	std::vector<std::string> files;
// 	GetFiles("*", files);
// 	ps::log::Log(ps::LogType::Normal, "Listing files from: %s", GetName().c_str());
//
// 	for (auto& file : files)
// 	{
// 		ps::log::Log(ps::LogType::Normal, "File: %s Available: 1", file.c_str());
// 	}
//
// 	ps::log::Log(ps::LogType::Normal, "Listed: %lu files.", files.size());
//
// 	return true;
// }

bool ps::CoDIWHandler::Exists(const std::string& ffName)
{
	if (!Initialized)
	{
		return false;
	}

	return std::filesystem::exists(GameDirectory + "\\" + ffName + ".ff");
}

bool ps::CoDIWHandler::LoadFastFile(const std::string& ffName, FastFile* parent, BitFlags<FastFileFlags> flags)
{
	auto newFastFile = CreateUniqueFastFile(ffName);

	newFastFile->Parent = parent;
	newFastFile->Flags = flags;

	// Set current ff for loading purposes.
	ps::Parasyte::PushTelemtry("LastFastFileName", ffName);
	ps::Parasyte::SetCurrentFastFile(newFastFile);

	ps::FileHandle ffHandle(FileSystem->OpenFile(GetFileName(ffName + ".ff"), "r"), FileSystem.get());
	ps::FileHandle fpHandle(FileSystem->OpenFile(GetFileName(ffName + ".fp"), "r"), FileSystem.get());

	if (!ffHandle.IsValid())
	{
		ps::log::Log(ps::LogType::Error, "The provided fast file could not be found in the game's file system.");
		ps::log::Log(ps::LogType::Error, "Make sure any updates are finished and check for any content packages.");

		throw std::exception("Could not open the fast file from the game's file system.");
	}

	bool success = true;

	auto magic = ffHandle.Read<uint64_t>();
	auto version = ffHandle.Read<uint32_t>();

	if (magic != 0x3030313066665749 && magic != 0x3030317566665749)
		throw std::exception("Invalid fast file magic number.");
	if (version != 0x653)
		throw std::exception("Invalid fast file version.");


	// TODO: We're making assumptions about PC fast files, these flags
	// contain information such as encryption, compression, etc. but in all
	// cases atm they are constant.
	auto flag0 = ffHandle.Read<uint8_t>();
	auto flag1 = ffHandle.Read<uint8_t>();
	auto flag2 = ffHandle.Read<uint8_t>();
	auto flag3 = ffHandle.Read<uint8_t>();
	auto padd0 = ffHandle.Read<uint64_t>();
	auto sizes = ffHandle.Read<ps::CoDIWInternal::BufferSizes>();

	// Read streamed data sizes, we need the asset file and image file information.
	auto b0 = (size_t)ffHandle.Read<uint32_t>();
	auto b1 = (size_t)ffHandle.Read<uint32_t>();
	auto b2 = (size_t)ffHandle.Read<uint32_t>();
	auto b3 = (size_t)ffHandle.Read<uint32_t>();

	auto assetFileBuffer = ffHandle.ReadArray<ps::CoDIWInternal::AssetFileRef>(b1);
	auto imageFileBuffer = ffHandle.ReadArray<ps::CoDIWInternal::AssetFileRef>(b3);

	// Sometimes these are 0? Not of use it seems for us, simply for
	// the game internally for allocating memory.
	auto totalSize = ffHandle.Read<uint64_t>();
	auto authSize = ffHandle.Read<uint64_t>();
	auto actualSize = ffHandle.Read<uint64_t>();

	for (size_t i = 0; i < 10; i++)
	{
		if (sizes.DataSizes[i] > 0)
		{
			ps::log::Log(ps::LogType::Verbose, "Allocating block: %llu of size: 0x%llx for file: %s", i, sizes.DataSizes[i], ffName.c_str());
			ps::Parasyte::GetCurrentFastFile()->MemoryBlocks[i].Initialize(sizes.DataSizes[i], 0x1000);
		}
	}

	ps::CoDIWInternal::AssignMemoryPointers(&ps::Parasyte::GetCurrentFastFile()->MemoryBlocks[0]);
	ps::CoDIWInternal::ClearAssetAlignment();
	ps::CoDIWInternal::AssetAlignmentInit();

	// Check if we have asset data, the way IW works, we load from these first before
	// the fast file actually loads, it seems to be mostly xmodel meshes so it must be
	// used to allow sharing of asset buffers across maps.
	if (b1 > 0)
	{
		ps::CoDIWInternal::PushZoneBlock(8);

		for (size_t i = 0; i < b1; i++)
		{
			auto& assetFileRef = assetFileBuffer[i];
			ps::log::Log(ps::LogType::Verbose, "Loading asset reference: %i in asset file: %i...", i, assetFileRef.PackageIndex);

			ps::FileHandle assetFileHandle(FileSystem->OpenFile("assetfile" + std::to_string(assetFileRef.PackageIndex) + ".pak", "r"), FileSystem.get());

			if (!assetFileHandle.IsValid())
				ps::log::Log(ps::LogType::Error, "Failed to find asset file index: %i", assetFileRef.PackageIndex);

			ps::CoDIWInternal::FFDecompressor = std::make_unique<LZ4DecompressorV2>(assetFileHandle, assetFileHandle.Read<uint64_t>() == 0x3030313066665749);

			assetFileHandle.Seek(assetFileBuffer[i].StartOffset, FILE_BEGIN);

			*ps::CoDIWInternal::VarXAssetHeader = ps::CoDIWInternal::AllocXAssetHeader();
			ps::CoDIWInternal::LoadXAssetHeader(1);
			ps::CoDIWInternal::PopZoneBlock();

			ps::log::Log(ps::LogType::Verbose, "Successfully loaded asset reference: %i in asset file: %i", i, assetFileRef.PackageIndex);
		}
	}


	ps::CoDIWInternal::FFDecompressor = std::make_unique<LZ4DecompressorV2>(ffHandle, magic == 0x3030313066665749);
	ps::CoDIWInternal::FPDecompressor = std::make_unique<LZ4DecompressorV2>(fpHandle, magic == 0x3030313066665749);

	// Now we can set up our fast file, secure means we have hash blocks.
	ps::CoDIWInternal::ImageIndex = 0;
	ps::CoDIWInternal::ImageCount = b3;
	ps::CoDIWInternal::ImageBuffer = imageFileBuffer.get();
	ps::CoDIWInternal::ParseFastFile(nullptr, ps::Parasyte::GetCurrentFastFile()->AssetList, ffName.c_str(), 0);

	// We must fix up any XModel surfs, as we may have overrode previous
	// temporary entries, etc.
	ps::Parasyte::GetCurrentHandler()->XAssetPools[8].EnumerateEntries([](ps::XAsset* asset)
	{
		ps::CoDIWInternal::XModelSurfsFixup((__int64)asset->Header);
	});

	ps::log::Log(ps::LogType::Normal, "Successfully loaded: %s", ffName.c_str());

	// If we have no parent, we are a root, and need to attempt to load the localized, etc.
	if (success && newFastFile->Parent == nullptr && !flags.HasFlag(ps::FastFileFlags::NoChildren))
	{
		auto techsetsName = "techsets_" + ffName;
		auto patchName = "patch_" + ffName;

		// Attempt to load the techsets file, this usually contains
		// materials, shaders, technique sets, etc.
		if (Exists(techsetsName) && !IsFastFileLoaded(techsetsName))
			LoadFastFile(techsetsName, newFastFile, flags);
		if (Exists(patchName) && !IsFastFileLoaded(patchName))
			LoadFastFile(patchName, newFastFile, flags);

		// Check for locale prefix
		if (!RegionPrefix.empty())
		{
			auto localeName      = RegionPrefix + ffName;
			auto localePatchName = RegionPrefix + "patch_" + ffName;

			// Now load the locale, not as important, as usually
			// only contains localized data.
			if(Exists(localeName) && !IsFastFileLoaded(localeName))
				LoadFastFile(localeName, newFastFile, flags);
			if (Exists(localePatchName) && !IsFastFileLoaded(localePatchName))
				LoadFastFile(localePatchName, newFastFile, flags);
		}
	}

	return true;
}

bool ps::CoDIWHandler::CleanUp()
{
	return true;
}

const std::string ps::CoDIWHandler::GetShorthand()
{
	return "iw";
}

PS_CINIT(ps::GameHandler, ps::CoDIWHandler, ps::GameHandler::GetHandlers());
#endif